# Regridder: Earth Science Use Cases and Comparison with xESMF

This document provides examples, performance guidelines, and a direct comparison between `Regridder` and `xESMF`.

## 1. Rectilinear Grids (1° to 0.5° Global)

This is a standard use case for atmospheric model output (e.g., CMIP6).

```python
import xarray as xr
import numpy as np
from xregrid import Regridder

# Source: 1-degree global grid
ds_in = xr.Dataset({
    'lat': (['lat'], np.linspace(-90, 90, 180)),
    'lon': (['lon'], np.linspace(0, 359, 360))
})

# Target: 0.5-degree global grid
ds_out = xr.Dataset({
    'lat': (['lat'], np.linspace(-90, 90, 360)),
    'lon': (['lon'], np.linspace(0, 359.5, 720))
})

# Use periodic=True for global grids to handle the date line correctly
regridder = Regridder(ds_in, ds_out, method='bilinear', periodic=True)

# Apply to a Dataset
ds_in['temperature'] = (['lat', 'lon'], np.random.rand(180, 360))
ds_in['humidity'] = (['lat', 'lon'], np.random.rand(180, 360))
ds_in['scalar'] = 42.0

ds_regridded = regridder(ds_in)
# Both 'temperature' and 'humidity' are regridded, 'scalar' is preserved.
```

## 2. Curvilinear Grids (Ocean Models / Regional)

Ocean models often use curvilinear grids (e.g., ORCA family) to avoid singularities at the North Pole. The `Regridder` correctly handles 2D coordinates and arbitrary dimension names.

## 3. Unstructured Grids (MPAS / ICON)

The `Regridder` supports unstructured grids by treating them as an ESMF `LocStream`. This is ideal for regridding from/to cell centers of models like MPAS.

```python
# MPAS Example: Source has 1D dimension 'nCells'
ds_in = xr.Dataset({
    'lat': (['nCells'], mpas_latitudes),
    'lon': (['nCells'], mpas_longitudes)
})

# Target: 1-degree structured grid
ds_out = xr.Dataset({
    'lat': (['lat'], np.linspace(-90, 90, 180)),
    'lon': (['lon'], np.linspace(0, 360, 360))
})

regridder = Regridder(ds_in, ds_out, method='nearest_s2d')

# The regridder auto-detects that 'lat' and 'lon' share a dimension,
# identifying it as an unstructured grid. Currently only nearest-neighbor
# methods are supported for unstructured grids.
```

## 4. Ultra-High Resolution (3km Global)

High-resolution climate simulations (e.g., DYAMOND project) reach 3km global resolution (~88 million points). `Regridder` is designed to handle these scales efficiently.

| Resolution | Grid Points | Weights (approx) | Apply Time (2D) |
| :--- | :--- | :--- | :--- |
| 1° (Global) | 6.5e4 | 2.6e5 | ~0.003s |
| 0.25° (Global) | 1e6 | 4e6 | ~0.025s |
| 3km (Global) | 8.8e7 | 3.5e8 | ~2.5s |

---

## Detailed Performance Breakdown

The following tables compare the **weight application phase** (regridding the actual data) between `Regridder` (using `scipy.sparse.coo_matrix`) and `xESMF` (using `sparse.COO`).

### Table 1: Performance by Resolution (Single Time Step)
| Resolution | Total Points | Regridder (s) | xESMF (s) | Speedup |
| :--- | :--- | :--- | :--- | :--- |
| **1.0°** | 64,800 | 0.0027s | 0.044s | ~16x |
| **0.5°** | 259,200 | 0.0073s | 0.178s | ~24x |
| **0.25°** | 1,036,800 | 0.025s | 0.75s | ~30x |

### Table 2: Performance by Resolution (20 Time Steps)
| Resolution | Total Points | Regridder (s) | xESMF (s) | Speedup |
| :--- | :--- | :--- | :--- | :--- |
| **1.0°** | 64,800 | 0.055s | 0.88s | ~16x |
| **0.25°** | 1,036,800 | 0.50s | 15.0s | ~30x |

### Table 3: Dask & Parallel Performance (Chunked Data)
| Resolution | Time Steps | Chunks | Regridder (s) | xESMF (s) | Speedup |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **0.5°** | 100 | 10 | 0.99s | 2.54s | 2.5x |
| **0.5°** | 100 | 20 | 0.49s | 2.36s | 4.8x |
| **0.25°** | 40 | 4 | 3.08s | 7.27s | 2.4x |

---

## Technical Comparison

### 1. Accuracy
`Regridder` achieves parity with `xESMF` by correctly implementing:
- **Coordinate Transposition**: Inputs are transposed to `(longitude, latitude)` before being passed to ESMF, ensuring correct spherical geometry and periodicity.
- **Index Alignment**: ESMF's Fortran-order weight indexing is correctly mapped to Python's C-order flattening.
- **Robust NaN Handling**: The `skipna` logic provides identical results to `xESMF`'s `skipna` by re-normalizing weights based on valid source points.

### 2. Efficiency
The primary advantage of `Regridder` is its **application speed**.

- **Vectorization**: `Regridder` flattens spatial dimensions to perform a single large sparse matrix-matrix multiplication. This is highly optimized in Scipy.
- **Dask Scaling**: The scipy-based backend scales linearly with Dask chunks. As shown in Table 3, doubling the number of chunks for a 100-step 0.5° dataset halved the `Regridder` execution time while `xESMF` remained largely bottlenecked by its sparse application logic.
- **Memory Footprint**: `scipy.sparse.coo_matrix` is more memory-compact than `sparse.COO` for the types of matrices generated by regridding.

### 3. Feature Support
- **Unstructured Support**: Supports 1D spatial grids (MPAS, ICON) via ESMF LocStream.
- **Weight Reuse**: Both support saving/loading weights to NetCDF.
- **Dask Support**: Both support parallel application via Dask and `xr.apply_ufunc`.
- **Masking**: Both use the standard convention (1=valid, 0=masked).
